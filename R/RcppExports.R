# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Function that performs linear regression
#' and saves the diagonal of the hat matrix
#'
#' @param X an nxk numeric data matrix
#' @param y The nx1 numeric output vector
#' @param w an nx1 numeric vector of weights
#' @param compute_se binary; 1 to compute VCV matrix, 0 otherwise
#' @param compute_hat binary; 1 to compute diagonal of hat matrix, 0 otherwise
#' @export
fastols <- function(X, y, w, compute_se = 1L, compute_hat = 0L) {
    .Call(`_looperr_fastols`, X, y, w, compute_se, compute_hat)
}

#' Function that performs linear regression
#' and saves the diagonal of the hat matrix
#'
#' @param X an nxk numeric data matrix
#' @param y The nx1 numeric output vector
#' @param g an nx1 sorted integer vector of groups
#' @param nthr integer; number of threads to use for parallel processing
#' @param compute_se binary; 1 if se should be computed, 0 if not. 1 by default
#' @param compute_hat binary; 1 if diagonal of at matrix should be calculated,
#'     0 if not. 0 by default.
fastols_by <- function(X, y, g, nthr = 1L, compute_se = 1L, compute_hat = 0L) {
    .Call(`_looperr_fastols_by`, X, y, g, nthr, compute_se, compute_hat)
}

#' Function that performs linear regression
#' and saves the diagonal of the hat matrix
#'
#' @param X an nxk numeric data matrix
#' @param y The nx1 numeric output vector
#' @param w an nx1 numeric vector of weights
#' @param g an nx1 sorted integer vector of groups
#' @param nthr integer; number of threads to use for parallel processing
#' @param compute_se binary; 1 if se should be computed, 0 if not. 1 by default
#' @param compute_hat binary; 1 if diagonal of at matrix should be calculated,
#'     0 if not. 0 by default.
fastols_bywt <- function(X, y, w, g, nthr = 1L, compute_se = 1L, compute_hat = 0L) {
    .Call(`_looperr_fastols_bywt`, X, y, w, g, nthr, compute_se, compute_hat)
}

#' Function that performs local linear regression
#' using Gaussian or Epanechnikov kernel.
#' @param X an nxk data matrix
#' @param y The nx1 output vector
#' @param H a kxk positive definite bandwidth matrix
#' @param Xeval an mxp matrix at which to predict using local linear regression
#' @param kernel integer; 1 for Gaussian, 2 for Epanechnikov
#' @param nthr positive integer; number of threads
loclin_diffX <- function(X, y, H, Xeval, kernel, nthr = 1L) {
    .Call(`_looperr_loclin_diffX`, X, y, H, Xeval, kernel, nthr)
}

#' Function that performs local linear regression
#' using Gaussian or Epanechnikov kernel.
#'
#' @param X an nxk data matrix
#' @param y The nx1 output vector
#' @param H a kxk positive definite bandwidth matrix
#' @param kernel integer; 1 for Gaussian, 2 for Epanechnikov
#' @param nthr positive integer; number of threads
loclin_sameX <- function(X, y, H, kernel, nthr = 1L) {
    .Call(`_looperr_loclin_sameX`, X, y, H, kernel, nthr)
}

#' Function that performs local linear regression
#' using Gaussian or Epanechnikov kernel.
#'
#' @param X an nxk data matrix
#' @param y The nx1 output vector
#' @param H a kxk positive definite bandwidth matrix
loclin_sameX_unif <- function(X, y, H) {
    .Call(`_looperr_loclin_sameX_unif`, X, y, H)
}

#' Function that performs local linear regression
#' using Gaussian or Epanechnikov kernel.
#'
#' @param X an nxk data matrix
#' @param y The nx1 output vector
#' @param H a kxk positive definite bandwidth matrix
#' @param Xeval an mxp matrix at which to predict using local linear regression
loclin_diffX_unif <- function(X, y, H, Xeval) {
    .Call(`_looperr_loclin_diffX_unif`, X, y, H, Xeval)
}

#' Function that performs local linear regression
#' using uniform kernel, by group
#'
#' @param X an nxk data matrix
#' @param y The nx1 output vector
#' @param g nx1 integer vector
#' @param H a kxk positive definite bandwidth matrix
#' @param nthr positive integer; number of threads
loclin_sameX_unif_by <- function(X, y, g, H, nthr = 1L) {
    .Call(`_looperr_loclin_sameX_unif_by`, X, y, g, H, nthr)
}

